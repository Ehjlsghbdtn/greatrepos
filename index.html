<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js 3D Scene with Physics</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
    <canvas id="renderCanvas" style="width: 100%; height: 100vh;"></canvas>
    <script>
        // Инициализация сцены
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);

            // Включаем физику для сцены
            scene.enablePhysics(new BABYLON.Vector3(0, -12, 0), new BABYLON.CannonJSPlugin());

            // Устанавливаем цвет окружения
            scene.clearColor = new BABYLON.Color3(0.85, 0.85, 0.85);

            // Камера
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 10, new BABYLON.Vector3(0, 1, 2), scene);
            camera.attachControl(canvas, true);
            camera.inputs.clear();
            camera.setTarget(new BABYLON.Vector3(0, 1, 2));
            camera.position = new BABYLON.Vector3(0, 2, -7);

            // Свет
            const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-1, -10, 5), scene);
            light.position = new BABYLON.Vector3(0, 1, 20);
            light.intensity = 0.9;

            // Генератор теней
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.setDarkness(0.5);

            // Пол
            const ground = BABYLON.MeshBuilder.CreateBox("ground", { width: 5, height: 0.1, depth: 5 }, scene);
            ground.position.y = -0.05;
            const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("assets/floor.png", scene);
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material = groundMaterial;
            ground.receiveShadows = true;
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, {
                mass: 0,
                restitution: 0.5,
                friction: 0.8
            }, scene);

            // Столб
            const pole = BABYLON.MeshBuilder.CreateBox("pole", { width: 0.15, height: 4, depth: 0.15 }, scene);
            pole.position = new BABYLON.Vector3(0, 2, 2.4);
            const poleMaterial = new BABYLON.StandardMaterial("poleMaterial", scene);
            poleMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            pole.material = poleMaterial;
            pole.receiveShadows = true;
            pole.physicsImpostor = new BABYLON.PhysicsImpostor(pole, BABYLON.PhysicsImpostor.BoxImpostor, {
                mass: 0,
                restitution: 0.1,
                friction: 0.9
            }, scene);

            // Щит
            const shield = BABYLON.MeshBuilder.CreateBox("shield", { width: 1.8, height: 1.05, depth: 0.1 }, scene);
            shield.position = new BABYLON.Vector3(0, 3.5, 2.3);
            shield.rotation.y = Math.PI;
            const shieldMaterial = new BABYLON.StandardMaterial("shieldMaterial", scene);
            shieldMaterial.diffuseTexture = new BABYLON.Texture("assets/shit.png", scene);
            shield.material = shieldMaterial;
            shield.receiveShadows = true;
            shield.physicsImpostor = new BABYLON.PhysicsImpostor(shield, BABYLON.PhysicsImpostor.BoxImpostor, {
                mass: 0,
                restitution: 0.2,
                friction: 0.8
            }, scene);

            // Кольцо (реалистичное, с пустым центром)
            const hoopOuter = BABYLON.MeshBuilder.CreateTorus("hoopOuter", { diameter: 0.48, thickness: 0.02 }, scene);
            hoopOuter.position = new BABYLON.Vector3(0, 3.15, 1.95);
            const hoopOuterMaterial = new BABYLON.StandardMaterial("hoopOuterMaterial", scene);
            hoopOuterMaterial.diffuseTexture = new BABYLON.Texture("assets/hoop.png", scene);
            hoopOuter.material = hoopOuterMaterial;
            hoopOuter.receiveShadows = true;

            // Разделяем на физические области только для обода
            hoopOuter.physicsImpostor = new BABYLON.PhysicsImpostor(hoopOuter, BABYLON.PhysicsImpostor.MeshImpostor, {
            mass: 0,
            restitution: 0.5,
            friction: 0.7,
}, scene);

            // Создаём внутренний пустой объект, чтобы визуализировать "пустое" пространство
            const hoopInner = BABYLON.MeshBuilder.CreateTorus("hoopInner", { diameter: 0.45, thickness: 0.01 }, scene);
            hoopInner.position = hoopOuter.position;
            const hoopInnerMaterial = new BABYLON.StandardMaterial("hoopInnerMaterial", scene);
            hoopInnerMaterial.alpha = 0; // Делаем его полностью прозрачным
            hoopInner.material = hoopInnerMaterial;

            // Убираем физику для внутреннего пустого пространства
            hoopInner.isVisible = false;
            hoopInner.physicsImpostor = null;

            // Создание маленького прямоугольника (держащего устройства)
            const holder = BABYLON.MeshBuilder.CreateBox("holder", {
            width: 0.2,   // Ширина
            height: 0.11,  // Высота
            depth: 0.1    // Глубина
            }, scene);

            // Установка красного материала для прямоугольника
            const holderMaterial = new BABYLON.StandardMaterial("holderMaterial", scene);
            holderMaterial.diffuseTexture = new BABYLON.Texture("assets/hoop.png", scene);
            holder.material = holderMaterial;

            // Размещение прямоугольника рядом с щитом
            holder.position = new BABYLON.Vector3(0, 3.1, 2.225); // Корректируйте положение по вашему усмотрению

            // Мяч
        const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 0.4 }, scene);
        ball.position = new BABYLON.Vector3(0, 2, -3);
        const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
            ballMaterial.diffuseTexture = new BABYLON.Texture("assets/ball.png", scene);
            ball.material = ballMaterial;
            shadowGenerator.addShadowCaster(ball);
        ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, {
            mass: 1,
            restitution: 0.8,
            friction: 0.5
        }, scene);

        ball.physicsImpostor.sleep(); // Замораживаем мяч при старте

        let isMouseDown = false;
let isBallSelected = false;
let initialMousePos = null;
let initialTime = null;
let trajectoryPoints = []; // Массив для хранения точек траектории
let gravity = 12; // Ускорение гравитации
let trajectoryUpdateInterval = null; // Интервал для обновления траектории
let lastDirection = null; // Последний вектор направления

// Функция для вычисления траектории
function calculateTrajectory(force, direction, maxTime) {
    const points = [];
    const step = 0.1; // Шаг времени для расчета точек
    for (let t = 0; t <= maxTime; t += step) {
        const x = ball.position.x + force * direction.x * t;
        const z = ball.position.z + force * direction.z * t;
        const y = ball.position.y + force * direction.y * t - 0.5 * gravity * t * t;

        if (y < 0) break; // Прекращаем расчет, если точка ниже земли
        points.push(new BABYLON.Vector3(x, y, z));
    }
    return points;
}

// Функция для отрисовки траектории точками
function drawTrajectory(scene, points) {
    // Удаляем предыдущие точки
    trajectoryPoints.forEach(point => point.dispose());
    trajectoryPoints = [];

    // Создаем новые точки
    points.forEach(point => {
        const sphere = BABYLON.MeshBuilder.CreateSphere("trajectoryPoint", { diameter: 0.05 }, scene);
        sphere.position = point;
        const sphereMaterial = new BABYLON.StandardMaterial("sphereMaterial", scene);
        sphereMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Красный цвет
        sphere.material = sphereMaterial;
        trajectoryPoints.push(sphere);
    });
}

// Удержание кнопки
canvas.addEventListener("pointerdown", (e) => {
    const pickResult = scene.pick(e.clientX, e.clientY);
    if (pickResult.hit && pickResult.pickedMesh === ball) {
        isMouseDown = true;
        isBallSelected = true;
        initialMousePos = new BABYLON.Vector2(e.clientX, e.clientY);
        initialTime = Date.now();

        // Запускаем обновление траектории в реальном времени
        trajectoryUpdateInterval = setInterval(() => {
            if (isMouseDown && isBallSelected) {
                const holdTime = (Date.now() - initialTime) / 1000; // Время удержания
                const forceMagnitude = Math.min(holdTime * 5, 10); // Сила броска

                const direction = lastDirection || new BABYLON.Vector3(0, 0, 1).normalize(); // Используем последний сохранённый direction
                const points = calculateTrajectory(forceMagnitude, direction, 3); // Рассчитываем траекторию на 3 секунды
                drawTrajectory(scene, points);
            }
        }, 50); // Обновляем каждые 50 мс
    }
});

// Обновление направления при движении мыши
canvas.addEventListener("pointermove", (e) => {
    if (isMouseDown && isBallSelected) {
        const currentMousePos = new BABYLON.Vector2(e.clientX, e.clientY);
        const delta = currentMousePos.subtract(initialMousePos);
        lastDirection = new BABYLON.Vector3(delta.x * 0.01, -delta.y * 0.01, 3).normalize(); // Сохраняем направление

        const holdTime = (Date.now() - initialTime) / 1000;
        const forceMagnitude = Math.min(holdTime * 5, 10);

        const points = calculateTrajectory(forceMagnitude, lastDirection, 3); // Обновляем точки траектории
        drawTrajectory(scene, points);
    }
});

// Отпускание кнопки
canvas.addEventListener("pointerup", (e) => {
    if (isMouseDown && isBallSelected) {
        const releaseMousePos = new BABYLON.Vector2(e.clientX, e.clientY);
        const delta = releaseMousePos.subtract(initialMousePos);

        const direction = lastDirection || new BABYLON.Vector3(0, 0, 1).normalize(); // Используем последний direction
        const holdTime = (Date.now() - initialTime) / 1000;
        const forceMagnitude = Math.min(holdTime * 5, 10);
        const force = direction.scale(forceMagnitude);

        ball.physicsImpostor.wakeUp();
        ball.physicsImpostor.applyImpulse(force, ball.getAbsolutePosition());

        // Сбрасываем состояния
        isMouseDown = false;
        isBallSelected = false;
        initialMousePos = null;
        initialTime = null;
        lastDirection = null; // Сбрасываем lastDirection

        // Очищаем интервал обновления траектории
        clearInterval(trajectoryUpdateInterval);
        trajectoryUpdateInterval = null;

        // Удаляем точки траектории
        trajectoryPoints.forEach(point => point.dispose());
        trajectoryPoints = [];
    }
});

// Стартовая позиция мяча
const startPosition = new BABYLON.Vector3(0, 2, -3);

// Функция для возврата мяча
function resetBall() {
    setTimeout(() => {
        ball.physicsImpostor.sleep(); // Замораживаем мяч
        ball.position = startPosition.clone(); // Возвращаем в начальную позицию
        ball.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero()); // Сбрасываем скорость
        ball.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero()); // Сбрасываем вращение
    }, 1000); // Задержка в 1 секунду
}

// Отслеживание событий физики
scene.registerBeforeRender(() => {
    if (ball.position.y < -1) {
        // Если мяч ниже пола
        resetBall();
    }

    const bounds = { x: 3, y: 4, z: 5 }; // Границы куба
    if (
        Math.abs(ball.position.x) > bounds.x ||
        Math.abs(ball.position.y) > bounds.y ||
        Math.abs(ball.position.z) > bounds.z
    ) {
        // Если мяч выходит за пределы куба
        resetBall();
    }
});

// Добавим проверку касания пола через импостор
ball.physicsImpostor.registerOnPhysicsCollide(ground.physicsImpostor, () => {
    resetBall();
});

        return scene;
    };

    const scene = createScene();
    engine.runRenderLoop(() => {
        scene.render();
    });

    window.addEventListener("resize", () => {
        engine.resize();
    });
</script>
</body>
</html>
